# Generated from job.g4 by ANTLR 4.8
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3%")
        buf.write("\u00d1\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\3\2\3\2\3\2\7\2*\n\2\f\2\16\2-\13\2\3\3\3\3\3\3\5\3\62")
        buf.write("\n\3\3\4\3\4\3\4\3\5\3\5\6\59\n\5\r\5\16\5:\3\6\3\6\3")
        buf.write("\6\7\6@\n\6\f\6\16\6C\13\6\3\6\3\6\3\7\3\7\6\7I\n\7\r")
        buf.write("\7\16\7J\3\7\3\7\6\7O\n\7\r\7\16\7P\3\7\3\7\6\7U\n\7\r")
        buf.write("\7\16\7V\3\7\3\7\6\7[\n\7\r\7\16\7\\\5\7_\n\7\3\b\3\b")
        buf.write("\3\b\7\bd\n\b\f\b\16\bg\13\b\3\b\3\b\3\t\3\t\3\t\5\tn")
        buf.write("\n\t\3\n\3\n\3\n\7\ns\n\n\f\n\16\nv\13\n\3\n\3\n\5\nz")
        buf.write("\n\n\3\n\7\n}\n\n\f\n\16\n\u0080\13\n\3\n\3\n\3\13\3\13")
        buf.write("\3\13\3\13\3\13\3\13\3\13\6\13\u008b\n\13\r\13\16\13\u008c")
        buf.write("\3\13\3\13\6\13\u0091\n\13\r\13\16\13\u0092\3\13\3\13")
        buf.write("\5\13\u0097\n\13\3\13\3\13\3\f\3\f\3\f\7\f\u009e\n\f\f")
        buf.write("\f\16\f\u00a1\13\f\3\f\3\f\3\r\3\r\3\r\3\r\3\r\3\r\3\r")
        buf.write("\3\16\3\16\3\16\7\16\u00af\n\16\f\16\16\16\u00b2\13\16")
        buf.write("\3\16\3\16\3\17\3\17\3\17\3\17\5\17\u00ba\n\17\3\20\3")
        buf.write("\20\6\20\u00be\n\20\r\20\16\20\u00bf\3\21\3\21\6\21\u00c4")
        buf.write("\n\21\r\21\16\21\u00c5\3\22\3\22\6\22\u00ca\n\22\r\22")
        buf.write("\16\22\u00cb\3\23\3\23\3\23\3\23\2\2\24\2\4\6\b\n\f\16")
        buf.write("\20\22\24\26\30\32\34\36 \"$\2\6\3\2\4\5\3\2\37 \4\2\17")
        buf.write("\17!!\3\2\25\27\2\u00de\2+\3\2\2\2\4\61\3\2\2\2\6\63\3")
        buf.write("\2\2\2\b\66\3\2\2\2\n<\3\2\2\2\f^\3\2\2\2\16`\3\2\2\2")
        buf.write("\20m\3\2\2\2\22o\3\2\2\2\24\u0083\3\2\2\2\26\u009a\3\2")
        buf.write("\2\2\30\u00a4\3\2\2\2\32\u00ab\3\2\2\2\34\u00b9\3\2\2")
        buf.write("\2\36\u00bb\3\2\2\2 \u00c1\3\2\2\2\"\u00c7\3\2\2\2$\u00cd")
        buf.write("\3\2\2\2&*\5\4\3\2\'*\5\6\4\2(*\5\b\5\2)&\3\2\2\2)\'\3")
        buf.write("\2\2\2)(\3\2\2\2*-\3\2\2\2+)\3\2\2\2+,\3\2\2\2,\3\3\2")
        buf.write("\2\2-+\3\2\2\2.\62\5\n\6\2/\62\5\16\b\2\60\62\5\32\16")
        buf.write("\2\61.\3\2\2\2\61/\3\2\2\2\61\60\3\2\2\2\62\5\3\2\2\2")
        buf.write("\63\64\7\3\2\2\64\65\t\2\2\2\65\7\3\2\2\2\668\7\6\2\2")
        buf.write("\679\7\"\2\28\67\3\2\2\29:\3\2\2\2:8\3\2\2\2:;\3\2\2\2")
        buf.write(";\t\3\2\2\2<=\7\7\2\2=A\7\b\2\2>@\5\f\7\2?>\3\2\2\2@C")
        buf.write("\3\2\2\2A?\3\2\2\2AB\3\2\2\2BD\3\2\2\2CA\3\2\2\2DE\7\t")
        buf.write("\2\2E\13\3\2\2\2FH\7\30\2\2GI\7\"\2\2HG\3\2\2\2IJ\3\2")
        buf.write("\2\2JH\3\2\2\2JK\3\2\2\2K_\3\2\2\2LN\7\31\2\2MO\7\"\2")
        buf.write("\2NM\3\2\2\2OP\3\2\2\2PN\3\2\2\2PQ\3\2\2\2Q_\3\2\2\2R")
        buf.write("T\7\32\2\2SU\7\"\2\2TS\3\2\2\2UV\3\2\2\2VT\3\2\2\2VW\3")
        buf.write("\2\2\2W_\3\2\2\2XZ\7\33\2\2Y[\7\"\2\2ZY\3\2\2\2[\\\3\2")
        buf.write("\2\2\\Z\3\2\2\2\\]\3\2\2\2]_\3\2\2\2^F\3\2\2\2^L\3\2\2")
        buf.write("\2^R\3\2\2\2^X\3\2\2\2_\r\3\2\2\2`a\7\n\2\2ae\7\b\2\2")
        buf.write("bd\5\20\t\2cb\3\2\2\2dg\3\2\2\2ec\3\2\2\2ef\3\2\2\2fh")
        buf.write("\3\2\2\2ge\3\2\2\2hi\7\t\2\2i\17\3\2\2\2jn\5\22\n\2kn")
        buf.write("\5\26\f\2ln\5\24\13\2mj\3\2\2\2mk\3\2\2\2ml\3\2\2\2n\21")
        buf.write("\3\2\2\2op\7\13\2\2pt\7\b\2\2qs\5\30\r\2rq\3\2\2\2sv\3")
        buf.write("\2\2\2tr\3\2\2\2tu\3\2\2\2uy\3\2\2\2vt\3\2\2\2wx\7\36")
        buf.write("\2\2xz\t\3\2\2yw\3\2\2\2yz\3\2\2\2z~\3\2\2\2{}\5\30\r")
        buf.write("\2|{\3\2\2\2}\u0080\3\2\2\2~|\3\2\2\2~\177\3\2\2\2\177")
        buf.write("\u0081\3\2\2\2\u0080~\3\2\2\2\u0081\u0082\7\t\2\2\u0082")
        buf.write("\23\3\2\2\2\u0083\u0084\7\f\2\2\u0084\u0096\7\b\2\2\u0085")
        buf.write("\u0086\7\34\2\2\u0086\u0087\7!\2\2\u0087\u0088\3\2\2\2")
        buf.write("\u0088\u008a\7\35\2\2\u0089\u008b\7\"\2\2\u008a\u0089")
        buf.write("\3\2\2\2\u008b\u008c\3\2\2\2\u008c\u008a\3\2\2\2\u008c")
        buf.write("\u008d\3\2\2\2\u008d\u0097\3\2\2\2\u008e\u0090\7\35\2")
        buf.write("\2\u008f\u0091\7\"\2\2\u0090\u008f\3\2\2\2\u0091\u0092")
        buf.write("\3\2\2\2\u0092\u0090\3\2\2\2\u0092\u0093\3\2\2\2\u0093")
        buf.write("\u0094\3\2\2\2\u0094\u0095\7\34\2\2\u0095\u0097\7!\2\2")
        buf.write("\u0096\u0085\3\2\2\2\u0096\u008e\3\2\2\2\u0096\u0097\3")
        buf.write("\2\2\2\u0097\u0098\3\2\2\2\u0098\u0099\7\t\2\2\u0099\25")
        buf.write("\3\2\2\2\u009a\u009b\7\r\2\2\u009b\u009f\7\b\2\2\u009c")
        buf.write("\u009e\5\30\r\2\u009d\u009c\3\2\2\2\u009e\u00a1\3\2\2")
        buf.write("\2\u009f\u009d\3\2\2\2\u009f\u00a0\3\2\2\2\u00a0\u00a2")
        buf.write("\3\2\2\2\u00a1\u009f\3\2\2\2\u00a2\u00a3\7\t\2\2\u00a3")
        buf.write("\27\3\2\2\2\u00a4\u00a5\7\16\2\2\u00a5\u00a6\t\4\2\2\u00a6")
        buf.write("\u00a7\t\4\2\2\u00a7\u00a8\t\4\2\2\u00a8\u00a9\t\4\2\2")
        buf.write("\u00a9\u00aa\t\4\2\2\u00aa\31\3\2\2\2\u00ab\u00ac\7\20")
        buf.write("\2\2\u00ac\u00b0\7\b\2\2\u00ad\u00af\5\34\17\2\u00ae\u00ad")
        buf.write("\3\2\2\2\u00af\u00b2\3\2\2\2\u00b0\u00ae\3\2\2\2\u00b0")
        buf.write("\u00b1\3\2\2\2\u00b1\u00b3\3\2\2\2\u00b2\u00b0\3\2\2\2")
        buf.write("\u00b3\u00b4\7\t\2\2\u00b4\33\3\2\2\2\u00b5\u00ba\5\36")
        buf.write("\20\2\u00b6\u00ba\5 \21\2\u00b7\u00ba\5\"\22\2\u00b8\u00ba")
        buf.write("\5$\23\2\u00b9\u00b5\3\2\2\2\u00b9\u00b6\3\2\2\2\u00b9")
        buf.write("\u00b7\3\2\2\2\u00b9\u00b8\3\2\2\2\u00ba\35\3\2\2\2\u00bb")
        buf.write("\u00bd\7\21\2\2\u00bc\u00be\7\"\2\2\u00bd\u00bc\3\2\2")
        buf.write("\2\u00be\u00bf\3\2\2\2\u00bf\u00bd\3\2\2\2\u00bf\u00c0")
        buf.write("\3\2\2\2\u00c0\37\3\2\2\2\u00c1\u00c3\7\22\2\2\u00c2\u00c4")
        buf.write("\7\"\2\2\u00c3\u00c2\3\2\2\2\u00c4\u00c5\3\2\2\2\u00c5")
        buf.write("\u00c3\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6!\3\2\2\2\u00c7")
        buf.write("\u00c9\7\23\2\2\u00c8\u00ca\7\"\2\2\u00c9\u00c8\3\2\2")
        buf.write("\2\u00ca\u00cb\3\2\2\2\u00cb\u00c9\3\2\2\2\u00cb\u00cc")
        buf.write("\3\2\2\2\u00cc#\3\2\2\2\u00cd\u00ce\7\24\2\2\u00ce\u00cf")
        buf.write("\t\5\2\2\u00cf%\3\2\2\2\32)+\61:AJPV\\^emty~\u008c\u0092")
        buf.write("\u0096\u009f\u00b0\u00b9\u00bf\u00c5\u00cb")
        return buf.getvalue()


class jobParser ( Parser ):

    grammarFileName = "job.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'style'", "'free'", "'maven'", "'project_name'", 
                     "'source'", "'{'", "'}'", "'build_triggers'", "'poll_scm'", 
                     "'build_after_other_projects'", "'build_periodically'", 
                     "'p-'", "'*'", "'building'", "'sh-'", "'goals_options'", 
                     "'root_pom'", "'post_step'", "'run_if_build_succeed'", 
                     "'run_if_build_succeed_unstable'", "'run_regardless'", 
                     "'project_url'", "'git_repo_urls'", "'git_repo_branches'", 
                     "'credential_name'", "'trigger_method'", "'project_names'", 
                     "'ignore_post_commit_hooks'", "'yes'", "'no'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "Project_url", "Git_repo_urls", 
                      "Git_repo_branches", "Credential_name", "Trigger_method", 
                      "Project_names", "Ignore_post_commit_hooks", "Yes", 
                      "No", "DIGIT", "Identifier", "COMMENT", "BlockComment", 
                      "WS" ]

    RULE_job = 0
    RULE_configuration_scopes = 1
    RULE_style = 2
    RULE_project_name = 3
    RULE_project_source_scope = 4
    RULE_project_source_op = 5
    RULE_build_triggers_scope = 6
    RULE_triggers = 7
    RULE_poll_scm = 8
    RULE_build_after_other_projects = 9
    RULE_build_priodically = 10
    RULE_pattern = 11
    RULE_building_scope = 12
    RULE_build_directives = 13
    RULE_shell_command = 14
    RULE_goals_option = 15
    RULE_root_pom = 16
    RULE_post_step = 17

    ruleNames =  [ "job", "configuration_scopes", "style", "project_name", 
                   "project_source_scope", "project_source_op", "build_triggers_scope", 
                   "triggers", "poll_scm", "build_after_other_projects", 
                   "build_priodically", "pattern", "building_scope", "build_directives", 
                   "shell_command", "goals_option", "root_pom", "post_step" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    Project_url=22
    Git_repo_urls=23
    Git_repo_branches=24
    Credential_name=25
    Trigger_method=26
    Project_names=27
    Ignore_post_commit_hooks=28
    Yes=29
    No=30
    DIGIT=31
    Identifier=32
    COMMENT=33
    BlockComment=34
    WS=35

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.8")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class JobContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def configuration_scopes(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jobParser.Configuration_scopesContext)
            else:
                return self.getTypedRuleContext(jobParser.Configuration_scopesContext,i)


        def style(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jobParser.StyleContext)
            else:
                return self.getTypedRuleContext(jobParser.StyleContext,i)


        def project_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jobParser.Project_nameContext)
            else:
                return self.getTypedRuleContext(jobParser.Project_nameContext,i)


        def getRuleIndex(self):
            return jobParser.RULE_job

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterJob" ):
                listener.enterJob(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitJob" ):
                listener.exitJob(self)




    def job(self):

        localctx = jobParser.JobContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_job)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 41
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << jobParser.T__0) | (1 << jobParser.T__3) | (1 << jobParser.T__4) | (1 << jobParser.T__7) | (1 << jobParser.T__13))) != 0):
                self.state = 39
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [jobParser.T__4, jobParser.T__7, jobParser.T__13]:
                    self.state = 36
                    self.configuration_scopes()
                    pass
                elif token in [jobParser.T__0]:
                    self.state = 37
                    self.style()
                    pass
                elif token in [jobParser.T__3]:
                    self.state = 38
                    self.project_name()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 43
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Configuration_scopesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project_source_scope(self):
            return self.getTypedRuleContext(jobParser.Project_source_scopeContext,0)


        def build_triggers_scope(self):
            return self.getTypedRuleContext(jobParser.Build_triggers_scopeContext,0)


        def building_scope(self):
            return self.getTypedRuleContext(jobParser.Building_scopeContext,0)


        def getRuleIndex(self):
            return jobParser.RULE_configuration_scopes

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConfiguration_scopes" ):
                listener.enterConfiguration_scopes(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConfiguration_scopes" ):
                listener.exitConfiguration_scopes(self)




    def configuration_scopes(self):

        localctx = jobParser.Configuration_scopesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_configuration_scopes)
        try:
            self.state = 47
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [jobParser.T__4]:
                self.enterOuterAlt(localctx, 1)
                self.state = 44
                self.project_source_scope()
                pass
            elif token in [jobParser.T__7]:
                self.enterOuterAlt(localctx, 2)
                self.state = 45
                self.build_triggers_scope()
                pass
            elif token in [jobParser.T__13]:
                self.enterOuterAlt(localctx, 3)
                self.state = 46
                self.building_scope()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StyleContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return jobParser.RULE_style

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStyle" ):
                listener.enterStyle(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStyle" ):
                listener.exitStyle(self)




    def style(self):

        localctx = jobParser.StyleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_style)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 49
            self.match(jobParser.T__0)
            self.state = 50
            _la = self._input.LA(1)
            if not(_la==jobParser.T__1 or _la==jobParser.T__2):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Project_nameContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(jobParser.Identifier)
            else:
                return self.getToken(jobParser.Identifier, i)

        def getRuleIndex(self):
            return jobParser.RULE_project_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject_name" ):
                listener.enterProject_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject_name" ):
                listener.exitProject_name(self)




    def project_name(self):

        localctx = jobParser.Project_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_project_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 52
            self.match(jobParser.T__3)
            self.state = 54 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 53
                self.match(jobParser.Identifier)
                self.state = 56 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==jobParser.Identifier):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Project_source_scopeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def project_source_op(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jobParser.Project_source_opContext)
            else:
                return self.getTypedRuleContext(jobParser.Project_source_opContext,i)


        def getRuleIndex(self):
            return jobParser.RULE_project_source_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject_source_scope" ):
                listener.enterProject_source_scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject_source_scope" ):
                listener.exitProject_source_scope(self)




    def project_source_scope(self):

        localctx = jobParser.Project_source_scopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_project_source_scope)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 58
            self.match(jobParser.T__4)
            self.state = 59
            self.match(jobParser.T__5)
            self.state = 63
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << jobParser.Project_url) | (1 << jobParser.Git_repo_urls) | (1 << jobParser.Git_repo_branches) | (1 << jobParser.Credential_name))) != 0):
                self.state = 60
                self.project_source_op()
                self.state = 65
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 66
            self.match(jobParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Project_source_opContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Project_url(self):
            return self.getToken(jobParser.Project_url, 0)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(jobParser.Identifier)
            else:
                return self.getToken(jobParser.Identifier, i)

        def Git_repo_urls(self):
            return self.getToken(jobParser.Git_repo_urls, 0)

        def Git_repo_branches(self):
            return self.getToken(jobParser.Git_repo_branches, 0)

        def Credential_name(self):
            return self.getToken(jobParser.Credential_name, 0)

        def getRuleIndex(self):
            return jobParser.RULE_project_source_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterProject_source_op" ):
                listener.enterProject_source_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitProject_source_op" ):
                listener.exitProject_source_op(self)




    def project_source_op(self):

        localctx = jobParser.Project_source_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_project_source_op)
        self._la = 0 # Token type
        try:
            self.state = 92
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [jobParser.Project_url]:
                self.enterOuterAlt(localctx, 1)
                self.state = 68
                self.match(jobParser.Project_url)
                self.state = 70 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 69
                    self.match(jobParser.Identifier)
                    self.state = 72 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==jobParser.Identifier):
                        break

                pass
            elif token in [jobParser.Git_repo_urls]:
                self.enterOuterAlt(localctx, 2)
                self.state = 74
                self.match(jobParser.Git_repo_urls)
                self.state = 76 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 75
                    self.match(jobParser.Identifier)
                    self.state = 78 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==jobParser.Identifier):
                        break

                pass
            elif token in [jobParser.Git_repo_branches]:
                self.enterOuterAlt(localctx, 3)
                self.state = 80
                self.match(jobParser.Git_repo_branches)

                self.state = 82 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 81
                    self.match(jobParser.Identifier)
                    self.state = 84 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==jobParser.Identifier):
                        break

                pass
            elif token in [jobParser.Credential_name]:
                self.enterOuterAlt(localctx, 4)
                self.state = 86
                self.match(jobParser.Credential_name)
                self.state = 88 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 87
                    self.match(jobParser.Identifier)
                    self.state = 90 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==jobParser.Identifier):
                        break

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Build_triggers_scopeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def triggers(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jobParser.TriggersContext)
            else:
                return self.getTypedRuleContext(jobParser.TriggersContext,i)


        def getRuleIndex(self):
            return jobParser.RULE_build_triggers_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuild_triggers_scope" ):
                listener.enterBuild_triggers_scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuild_triggers_scope" ):
                listener.exitBuild_triggers_scope(self)




    def build_triggers_scope(self):

        localctx = jobParser.Build_triggers_scopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_build_triggers_scope)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 94
            self.match(jobParser.T__7)
            self.state = 95
            self.match(jobParser.T__5)
            self.state = 99
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << jobParser.T__8) | (1 << jobParser.T__9) | (1 << jobParser.T__10))) != 0):
                self.state = 96
                self.triggers()
                self.state = 101
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 102
            self.match(jobParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class TriggersContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def poll_scm(self):
            return self.getTypedRuleContext(jobParser.Poll_scmContext,0)


        def build_priodically(self):
            return self.getTypedRuleContext(jobParser.Build_priodicallyContext,0)


        def build_after_other_projects(self):
            return self.getTypedRuleContext(jobParser.Build_after_other_projectsContext,0)


        def getRuleIndex(self):
            return jobParser.RULE_triggers

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTriggers" ):
                listener.enterTriggers(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTriggers" ):
                listener.exitTriggers(self)




    def triggers(self):

        localctx = jobParser.TriggersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_triggers)
        try:
            self.state = 107
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [jobParser.T__8]:
                self.enterOuterAlt(localctx, 1)
                self.state = 104
                self.poll_scm()
                pass
            elif token in [jobParser.T__10]:
                self.enterOuterAlt(localctx, 2)
                self.state = 105
                self.build_priodically()
                pass
            elif token in [jobParser.T__9]:
                self.enterOuterAlt(localctx, 3)
                self.state = 106
                self.build_after_other_projects()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Poll_scmContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jobParser.PatternContext)
            else:
                return self.getTypedRuleContext(jobParser.PatternContext,i)


        def Ignore_post_commit_hooks(self):
            return self.getToken(jobParser.Ignore_post_commit_hooks, 0)

        def Yes(self):
            return self.getToken(jobParser.Yes, 0)

        def No(self):
            return self.getToken(jobParser.No, 0)

        def getRuleIndex(self):
            return jobParser.RULE_poll_scm

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPoll_scm" ):
                listener.enterPoll_scm(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPoll_scm" ):
                listener.exitPoll_scm(self)




    def poll_scm(self):

        localctx = jobParser.Poll_scmContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_poll_scm)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 109
            self.match(jobParser.T__8)
            self.state = 110
            self.match(jobParser.T__5)

            self.state = 114
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,12,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 111
                    self.pattern() 
                self.state = 116
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,12,self._ctx)

            self.state = 119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==jobParser.Ignore_post_commit_hooks:
                self.state = 117
                self.match(jobParser.Ignore_post_commit_hooks)
                self.state = 118
                _la = self._input.LA(1)
                if not(_la==jobParser.Yes or _la==jobParser.No):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 124
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==jobParser.T__11:
                self.state = 121
                self.pattern()
                self.state = 126
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 127
            self.match(jobParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Build_after_other_projectsContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Trigger_method(self):
            return self.getToken(jobParser.Trigger_method, 0)

        def DIGIT(self):
            return self.getToken(jobParser.DIGIT, 0)

        def Project_names(self):
            return self.getToken(jobParser.Project_names, 0)

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(jobParser.Identifier)
            else:
                return self.getToken(jobParser.Identifier, i)

        def getRuleIndex(self):
            return jobParser.RULE_build_after_other_projects

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuild_after_other_projects" ):
                listener.enterBuild_after_other_projects(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuild_after_other_projects" ):
                listener.exitBuild_after_other_projects(self)




    def build_after_other_projects(self):

        localctx = jobParser.Build_after_other_projectsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_build_after_other_projects)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 129
            self.match(jobParser.T__9)
            self.state = 130
            self.match(jobParser.T__5)
            self.state = 148
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [jobParser.Trigger_method]:
                self.state = 131
                self.match(jobParser.Trigger_method)
                self.state = 132
                self.match(jobParser.DIGIT)

                self.state = 134
                self.match(jobParser.Project_names)
                self.state = 136 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 135
                    self.match(jobParser.Identifier)
                    self.state = 138 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==jobParser.Identifier):
                        break

                pass
            elif token in [jobParser.Project_names]:
                self.state = 140
                self.match(jobParser.Project_names)
                self.state = 142 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 141
                    self.match(jobParser.Identifier)
                    self.state = 144 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==jobParser.Identifier):
                        break


                self.state = 146
                self.match(jobParser.Trigger_method)
                self.state = 147
                self.match(jobParser.DIGIT)
                pass
            elif token in [jobParser.T__6]:
                pass
            else:
                pass
            self.state = 150
            self.match(jobParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Build_priodicallyContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def pattern(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jobParser.PatternContext)
            else:
                return self.getTypedRuleContext(jobParser.PatternContext,i)


        def getRuleIndex(self):
            return jobParser.RULE_build_priodically

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuild_priodically" ):
                listener.enterBuild_priodically(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuild_priodically" ):
                listener.exitBuild_priodically(self)




    def build_priodically(self):

        localctx = jobParser.Build_priodicallyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_build_priodically)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 152
            self.match(jobParser.T__10)
            self.state = 153
            self.match(jobParser.T__5)
            self.state = 157
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==jobParser.T__11:
                self.state = 154
                self.pattern()
                self.state = 159
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 160
            self.match(jobParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PatternContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(jobParser.DIGIT)
            else:
                return self.getToken(jobParser.DIGIT, i)

        def getRuleIndex(self):
            return jobParser.RULE_pattern

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPattern" ):
                listener.enterPattern(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPattern" ):
                listener.exitPattern(self)




    def pattern(self):

        localctx = jobParser.PatternContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_pattern)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 162
            self.match(jobParser.T__11)
            self.state = 163
            _la = self._input.LA(1)
            if not(_la==jobParser.T__12 or _la==jobParser.DIGIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 164
            _la = self._input.LA(1)
            if not(_la==jobParser.T__12 or _la==jobParser.DIGIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 165
            _la = self._input.LA(1)
            if not(_la==jobParser.T__12 or _la==jobParser.DIGIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 166
            _la = self._input.LA(1)
            if not(_la==jobParser.T__12 or _la==jobParser.DIGIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 167
            _la = self._input.LA(1)
            if not(_la==jobParser.T__12 or _la==jobParser.DIGIT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Building_scopeContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def build_directives(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(jobParser.Build_directivesContext)
            else:
                return self.getTypedRuleContext(jobParser.Build_directivesContext,i)


        def getRuleIndex(self):
            return jobParser.RULE_building_scope

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuilding_scope" ):
                listener.enterBuilding_scope(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuilding_scope" ):
                listener.exitBuilding_scope(self)




    def building_scope(self):

        localctx = jobParser.Building_scopeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_building_scope)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 169
            self.match(jobParser.T__13)
            self.state = 170
            self.match(jobParser.T__5)
            self.state = 174
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << jobParser.T__14) | (1 << jobParser.T__15) | (1 << jobParser.T__16) | (1 << jobParser.T__17))) != 0):
                self.state = 171
                self.build_directives()
                self.state = 176
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 177
            self.match(jobParser.T__6)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Build_directivesContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def shell_command(self):
            return self.getTypedRuleContext(jobParser.Shell_commandContext,0)


        def goals_option(self):
            return self.getTypedRuleContext(jobParser.Goals_optionContext,0)


        def root_pom(self):
            return self.getTypedRuleContext(jobParser.Root_pomContext,0)


        def post_step(self):
            return self.getTypedRuleContext(jobParser.Post_stepContext,0)


        def getRuleIndex(self):
            return jobParser.RULE_build_directives

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBuild_directives" ):
                listener.enterBuild_directives(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBuild_directives" ):
                listener.exitBuild_directives(self)




    def build_directives(self):

        localctx = jobParser.Build_directivesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_build_directives)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 183
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [jobParser.T__14]:
                self.state = 179
                self.shell_command()
                pass
            elif token in [jobParser.T__15]:
                self.state = 180
                self.goals_option()
                pass
            elif token in [jobParser.T__16]:
                self.state = 181
                self.root_pom()
                pass
            elif token in [jobParser.T__17]:
                self.state = 182
                self.post_step()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Shell_commandContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(jobParser.Identifier)
            else:
                return self.getToken(jobParser.Identifier, i)

        def getRuleIndex(self):
            return jobParser.RULE_shell_command

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShell_command" ):
                listener.enterShell_command(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShell_command" ):
                listener.exitShell_command(self)




    def shell_command(self):

        localctx = jobParser.Shell_commandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_shell_command)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 185
            self.match(jobParser.T__14)
            self.state = 187 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 186
                self.match(jobParser.Identifier)
                self.state = 189 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==jobParser.Identifier):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Goals_optionContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(jobParser.Identifier)
            else:
                return self.getToken(jobParser.Identifier, i)

        def getRuleIndex(self):
            return jobParser.RULE_goals_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGoals_option" ):
                listener.enterGoals_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGoals_option" ):
                listener.exitGoals_option(self)




    def goals_option(self):

        localctx = jobParser.Goals_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_goals_option)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 191
            self.match(jobParser.T__15)
            self.state = 193 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 192
                self.match(jobParser.Identifier)
                self.state = 195 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==jobParser.Identifier):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Root_pomContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self, i:int=None):
            if i is None:
                return self.getTokens(jobParser.Identifier)
            else:
                return self.getToken(jobParser.Identifier, i)

        def getRuleIndex(self):
            return jobParser.RULE_root_pom

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoot_pom" ):
                listener.enterRoot_pom(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoot_pom" ):
                listener.exitRoot_pom(self)




    def root_pom(self):

        localctx = jobParser.Root_pomContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_root_pom)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 197
            self.match(jobParser.T__16)
            self.state = 199 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 198
                self.match(jobParser.Identifier)
                self.state = 201 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==jobParser.Identifier):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Post_stepContext(ParserRuleContext):

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return jobParser.RULE_post_step

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPost_step" ):
                listener.enterPost_step(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPost_step" ):
                listener.exitPost_step(self)




    def post_step(self):

        localctx = jobParser.Post_stepContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_post_step)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 203
            self.match(jobParser.T__17)
            self.state = 204
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << jobParser.T__18) | (1 << jobParser.T__19) | (1 << jobParser.T__20))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





